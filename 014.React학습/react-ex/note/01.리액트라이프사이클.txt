[ 01.리액트 라이프사이클(life cycle) ]


1️⃣ 리액트의 생명주기

컴포넌트는 
생성(mounting) -> 업데이트(updating) -> 제거(unmounting)
의 생명주기를 가진다.

리액트 함수형 컴포넌트는 Hook을 사용한다!
리액트 클래스 컴포넌트는 라이프 사이클 메서드를 사용한다!

__________________________________
🎨 1.1. 함수형 컴포넌트 생명주기 🎨
----------------------------------

리액트에서 Hook은 함수형 컴포넌트에서 
React state와 생명주기 기능을 
연동 할 수 있게 해주는 함수이다.

Hook은 class 안에서는 동작하지 않고, 
class없이 React를 사용할 수 있게 한다.

__________________________________
🎃 리액트 훅(Hook)을 도입한 목적 🎃
----------------------------------

기존의 라이프사이클 메서드 기반이 아닌 로직 기반으로 
나눌 수 있어서 컴포넌트를 함수 단위로 잘게 쪼갤 수 있다는 장점이 있음!

라이프사이클 메서드에는 관련 없는 로직이 같은 메서드에 위치하게 되는데
이로인해 버그가 쉽게 발생하고, 무결성을 쉽게 망가지게 한다.

____________________________
🎃 Hook 사용 규칙 두가지 🎃
----------------------------

[1] 최상위 컴포넌트에서만 Hook을 호출한다.

[2] 반복문, 조건문, 중첩된 함수 내에서 Hook를 실행하지 않는다.
_________________________________________

이 규칙을 따르면 컴포넌트가 렌더링될 때마다 
항상 동일한 순서로 Hook이 호출되는 것이 보장된다.

리액트 함수 컴포넌트에서만 Hook을 호출해야 한다.
일반 JS함수에서는 Hook을 호출해서는 안된다.

_________________________
🎃 Hook의 종류와 정리 🎃
------------------------

☑️ useState
상태를 관리한다.
[state이름, setter이름] 순으로 반환 받아서 사용

const [변수, set변수] = useState(초기값);

-> set변수 (변수 첫글자 대문자)

☑️ useEffect
화면에 렌더링이 완료된 후에 실행됨!

componentDidMount와 componentDidUpdate, 
componentWillUnmount가 통합된 것!

🍓만약 화면을 다 그리기 이전에 동기화 되어야 하는 경우
useLayoutEffect를 활용한다!!!

컴포넌트 렌더링 -> useLayoutEffect 실행 -> 화면 업데이트 
순으로 effect를 실행시킬 수 있다!

☑️ useEffect 옵션 정리 :

1. 렌더링 결과가 실제 돔에 반영된 후마다 호출
useEffect(() => {});

2. 컴포넌트가 처음 나타날때 한 번 호출
useEffect(() => {}, []);

3. 조건부 effect 발생, 의존성 중 하나가 변경된다면 effect는 항상 재생성
useEffect(() => {}, [의존성1, 의존성2, ..]);

4. useEffect안에서의 return은 정리 함수(clean-up)를 사용하기위해 쓰임!
메모리 누수 방지를 위해 UI에서 컴포넌트를 제거하기 전에 수행
컴포넌트가 여러 번 렌더링 된다면 다음 effect가 수행되기 전에 
이전 effect가 정리된다!

(위의 useState / useEffect / useContext 는 기본 Hooks라고 부른다!)
참고:
https://ko.legacy.reactjs.org/docs/hooks-reference.html

☑️ React - 메모이제이션(Memoization) : 추가 Hooks

🍓 React에서 메모이제이션을 하는 방법

[1. useMemo]
[2. React.memo]
[3. useCallback]

🍓 메모이제이션(Memoization)
메모이제이션은 컴퓨터가 동일한 계산을 반복해야 할 때, 
이전에 계산한 값을 메모리에 저장함으로서 중복계산을 피하여
데이터 속도를 높이는 기술.보통 애플리케이션의 최적화를 위해 사용

1. useMemo -----------------------------------
useMemo를 사용하면 함수 컴포넌트 내부에서 발생하는 
연산을 최적화할 수 있음. 이전 값을 기억해두었다고 
조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용
메모이제이션된 값을 return하는 후크다!
+++++++++++++++++++++++++++++++++++++++++++++++++
const 변수 = useMemo(() => {}, [관리변수]);
관리변수 값이 변경되면 메모이제이션의 함수를 재실행함.
만약 인자를 전달하지 않는다면 매번 새롭게 계산하여 return함
___________________________________________________________

2. React.memo ------------------------------------
함수 컴포넌트에서는 일반적으로 라이프 사이클을 사용할 수 없음 
그래서 React.memo라는 함수를 사용함. 
컴포넌트의 props의 전달값이 변경돼야만 랜더링변경함
설정하여 함수 컴포넌트의 리렌더링 성능을 최적화함
(주의: 함수를 전달할 경우 매번 새로운값으로 인식함!)
+++++++++++++++++++++++++++++++++++++++++++++++
const Component = React.memo((props) => {
	return (컴포넌트 랜더링 코드)}
);
이전과 같은 props 값이 들어올 때는 렌더링 과정을 스킵
가장 최근에 렌더링된 결과를 재사용함 -> 이것이 메모이제이션임! 재사용!!!
단, 컴포넌트 내부에서 useState 훜 사용시 상태가 변경 되면 리렌더링됨
_______________________________________________________________

3. useCallback -------------------------------------
useCallback을 사용하면 만들어 놨던 함수를 재사용할 수 있음
컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 
생성되는 경우, 이미 사용된 같은 함수를 메모이제이션 하여 재사용함!
++++++++++++++++++++++++++++++++++++++++++++++++++++++
const [의존성변수, set의존성변수] = useState(초기값);
const 콜백 = useCallback(() => {}, 
[의존성변수]);

(주의: 콜백을 호출하는 코드가 재상용되는 메모이제이션처리 돼야 
콜백 호출이 부분 업데이트가 된다! 즉, 재상용되는 메모이제이션 처리된다!)